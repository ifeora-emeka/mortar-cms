"use client"

import React, { useState, useEffect } from 'react'
import styled from 'styled-components'
import { useRouter, usePathname } from 'next/navigation'
import { ArrowLeft, PlusCircle, Edit, Trash2, Info, AlertCircle, X, Check, Type, Hash, Calendar, Image, FileText, List, ToggleLeft, Lock, Zap } from 'lucide-react'
import { theme } from '../../../styles/theme'
import { Button } from '../../components/ui/Button'
import { Text } from '../../components/ui/Text'
import { PageBody } from '../../components/PageBody'
import { Table } from '../../components/ui/Table'
import { MessagePlaceholder } from '../../components/placeholders/MessagePlaceholder'
import { TablePlaceholder } from '../../components/placeholders/TablePlaceholder'
import { ErrorPlaceholder } from '../../components/placeholders/ErrorPlaceholder'
import { useToast } from '../../components/ToastProvider'
import api from '../../../lib/api'

interface SchemaFieldValidation {
    required?: boolean;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    min?: number;
    max?: number;
}

interface SchemaField {
    label: string;
    type: string;
    key: string;
    isStatic: boolean;
    autoGenerated: boolean;
    placeholder?: string;
    deriveValueFrom?: string;
    options?: Array<{ label: string; value: string }>;
}

interface SchemaItem {
    validation: SchemaFieldValidation;
    field: SchemaField;
}

interface CollectionSchema {
    _id: string;
    collection: string;
    schema: SchemaItem[];
    createdAt: string;
    updatedAt: string;
}

interface Collection {
    _id: string;
    name: string;
    slug: string;
    description?: string;
    createdAt: string;
    updatedAt: string;
}

const BackButton = styled(Button)`
  margin-right: ${theme.spacing.md};
  display: inline-flex;
  align-items: center;
  gap: ${theme.spacing.xs};
`

const NoFieldsContainer = styled.div`
  grid-column: 1 / -1;
  text-align: center;
  padding: ${theme.spacing.xl};
`

const FieldTypeIconContainer = styled.div<{ $fieldType?: string }>`
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: ${props => {
        switch (props.$fieldType) {
            case 'string': return `${theme.colors.primary}15`;
            case 'number': return `${theme.colors.warning}15`;
            case 'date': return `${theme.colors.secondary}15`;
            case 'image': return `${theme.colors.success}15`;
            case 'boolean': return `${theme.colors.warning}15`;
            case 'select': return `${theme.colors.info}15`;
            case 'richtext': return `${theme.colors.primary}10`;
            default: return `${theme.colors.muted}15`;
        }
    }};
  color: ${props => {
        switch (props.$fieldType) {
            case 'string': return theme.colors.primary;
            case 'number': return theme.colors.warning;
            case 'date': return theme.colors.secondary;
            case 'image': return theme.colors.success;
            case 'boolean': return theme.colors.warning;
            case 'select': return theme.colors.info;
            case 'richtext': return theme.colors.primary;
            default: return theme.colors.muted;
        }
    }};
`

const FieldBadge = styled.span<{ $type?: string }>`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background-color: ${props => {
        switch (props.$type) {
            case 'required': return `${theme.colors.error}15`;
            case 'static': return `${theme.colors.primary}15`;
            case 'auto': return `${theme.colors.success}15`;
            default: return `${theme.colors.muted}15`;
        }
    }};
  color: ${props => {
        switch (props.$type) {
            case 'required': return theme.colors.error;
            case 'static': return theme.colors.primary;
            case 'auto': return theme.colors.success;
            default: return theme.colors.muted;
        }
    }};
  padding: 2px 8px;
  border-radius: ${theme.borderRadius.sm};
  font-size: ${theme.fontSizes.xs};
  font-weight: 500;
  margin-right: 4px;
  margin-bottom: 4px;
`

const BadgesContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
`

const FieldNameContainer = styled.div`
  display: flex;
  flex-direction: column;
`

const FieldTypeCell = styled.div`
  display: flex;
  align-items: center;
  gap: ${theme.spacing.sm};
`

const ActionButtons = styled.div`
  display: flex;
  gap: ${theme.spacing.xs};
  justify-content: flex-end;
`

const StyledTableWrapper = styled.div`
  margin-top: ${theme.spacing.lg};
  width: 100%;
  overflow-x: auto;
  border-radius: ${theme.borderRadius.md};
  box-shadow: ${theme.shadows.sm};
  border: 1px solid ${theme.colors.border};
`

export default function CollectionDetailsPage() {
    const [collection, setCollection] = useState<Collection | null>(null)
    const [schema, setSchema] = useState<CollectionSchema | null>(null)
    const [isLoading, setIsLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)

    const router = useRouter()
    const pathname = usePathname()
    const { toast } = useToast()

    const collectionSlug = pathname?.split('/').pop() || ''

    useEffect(() => {
        if (collectionSlug) {
            fetchCollectionDetails(collectionSlug)
        }
    }, [collectionSlug])

    const fetchCollectionDetails = async (slug: string) => {
        if (!slug) return

        setIsLoading(true)
        setError(null)

        try {
            const [collectionResponse, schemaResponse] = await Promise.all([
                api.get(`/kyper/collections/get-by-slug/${slug}`),
                api.get(`/kyper/collections/get-schema-by-slug/${slug}`)
            ])

            if (collectionResponse.data && collectionResponse.data.data) {
                setCollection(collectionResponse.data.data)
            } else {
                throw new Error('Invalid collection response format')
            }

            if (schemaResponse.data && schemaResponse.data.data) {
                setSchema(schemaResponse.data.data)
            } else {
                throw new Error('Invalid schema response format')
            }

        } catch (err: any) {
            console.error('Error fetching collection details:', err)
            setError(err.response?.data?.message || err.message || 'Failed to load collection details')

            toast({
                title: "Error loading collection details",
                description: err.response?.data?.message || err.message || 'Failed to load collection details',
                duration: 5000
            })
        } finally {
            setIsLoading(false)
        }
    }

    const formatDate = (dateString: string) => {
        return new Date(dateString).toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
        })
    }

    const getFieldIcon = (fieldType: string) => {
        switch (fieldType) {
            case 'string': return <Type size={18} />;
            case 'number': return <Hash size={18} />;
            case 'date': return <Calendar size={18} />;
            case 'image': return <Image size={18} />;
            case 'boolean': return <ToggleLeft size={18} />;
            case 'select': return <List size={18} />;
            case 'richtext': return <FileText size={18} />;
            default: return <Info size={18} />;
        }
    }

    const goBack = () => {
        router.push('/admin/collections')
    }

    const renderFieldBadges = (item: SchemaItem) => (
        <BadgesContainer>
            {item.validation.required && (
                <FieldBadge $type="required">
                    <AlertCircle size={12} />
                    Required
                </FieldBadge>
            )}

            {item.field.isStatic && (
                <FieldBadge $type="static">
                    <Lock size={12} />
                    Static
                </FieldBadge>
            )}

            {item.field.autoGenerated && (
                <FieldBadge $type="auto">
                    <Zap size={12} />
                    Auto
                </FieldBadge>
            )}
        </BadgesContainer>
    )

    const renderSchemaTable = () => (
        <StyledTableWrapper>
            <Table.Root variant="striped" hover={true} stickyHeader={true} fullWidth={true}>
                <Table.Head>
                    <Table.Row>
                        <Table.Header>Field</Table.Header>
                        <Table.Header>Key</Table.Header>
                        <Table.Header>Type</Table.Header>
                        <Table.Header>Properties</Table.Header>
                        <Table.Header align="right">Actions</Table.Header>
                    </Table.Row>
                </Table.Head>
                <Table.Body>
                    {schema?.schema.map((item, index) => (
                        <Table.Row key={item.field.key || index} selected={item.field.isStatic}>
                            <Table.Cell>
                                <FieldNameContainer>
                                    <Text type="p" weight="medium">
                                        {item.field.label}
                                    </Text>
                                    {item.field.placeholder && (
                                        <Text type="small" muted>
                                            Placeholder: {item.field.placeholder}
                                        </Text>
                                    )}
                                    {renderFieldBadges(item)}
                                </FieldNameContainer>
                            </Table.Cell>
                            <Table.Cell>
                                <Text type="small">
                                    {item.field.key}
                                </Text>
                            </Table.Cell>
                            <Table.Cell>
                                <FieldTypeCell>
                                    <FieldTypeIconContainer $fieldType={item.field.type}>
                                        {getFieldIcon(item.field.type)}
                                    </FieldTypeIconContainer>
                                    <Text type="p">
                                        {item.field.type}
                                    </Text>
                                </FieldTypeCell>
                            </Table.Cell>
                            <Table.Cell>
                                <div>
                                    {item.field.deriveValueFrom && (
                                        <Text type="small">
                                            Derived from: <strong>{item.field.deriveValueFrom}</strong>
                                        </Text>
                                    )}
                                    {item.validation.maxLength && (
                                        <Text type="small">
                                            Max length: <strong>{item.validation.maxLength}</strong>
                                        </Text>
                                    )}
                                    {item.field.options && (
                                        <Text type="small">
                                            Options: <strong>{item.field.options.length}</strong>
                                        </Text>
                                    )}
                                </div>
                            </Table.Cell>
                            <Table.Cell align="right">
                                <ActionButtons>
                                    <Button variant="ghost" size="small" disabled={item.field.isStatic}>
                                        <Edit size={16} />
                                    </Button>
                                    <Button variant="ghost" size="small" color="error" disabled={item.field.isStatic}>
                                        <Trash2 size={16} />
                                    </Button>
                                </ActionButtons>
                            </Table.Cell>
                        </Table.Row>
                    ))}
                </Table.Body>
            </Table.Root>
        </StyledTableWrapper>
    )

    const renderContent = () => {
        if (isLoading) {
            return <TablePlaceholder rowCount={5} columnCount={5} animation="pulse" />
        }

        if (error) {
            return (
                <ErrorPlaceholder
                    heading="Error loading collection details"
                    subheading={error}
                    type="error"
                    variant="filled"
                    color="error"
                    retryText="Try Again"
                    onRetry={() => fetchCollectionDetails(collectionSlug)}
                />
            )
        }

        if (!collection || !schema) {
            return (
                <MessagePlaceholder
                    heading="Collection not found"
                    subheading="The collection you're looking for doesn't exist or may have been deleted"
                    icon={AlertCircle}
                    variant="outlined"
                    color="warning"
                    actions={
                        <Button
                            variant="solid"
                            color="primary"
                            onClick={goBack}
                        >
                            <ArrowLeft size={16} />
                            <span>Back to Collections</span>
                        </Button>
                    }
                />
            )
        }

        return (
            <>
                {schema.schema.length === 0 ? (
                    <NoFieldsContainer>
                        <MessagePlaceholder
                            heading="No Fields Defined"
                            subheading="This collection doesn't have any fields defined yet. Add your first field to get started."
                            icon={AlertCircle}
                            variant="outlined"
                            color="warning"
                            actions={
                                <Button
                                    variant="solid"
                                    color="primary"
                                >
                                    <PlusCircle size={16} />
                                    <span>Add Field</span>
                                </Button>
                            }
                        />
                    </NoFieldsContainer>
                ) : (
                    renderSchemaTable()
                )}
            </>
        )
    }

    return (
        <PageBody
            heading={
                collection?.name || 'Collection Details'
            }
            subheading={collection?.description || 'View and manage collection fields and schema'}
            rightContent={
                isLoading ? null : (
                    <>
                        <Button
                            variant="solid"
                            color="primary"
                            shadow="sm"
                            onClick={() => { }}
                        >
                            <PlusCircle size={16} />
                            <span>Add Field</span>
                        </Button>
                    </>
                )
            }
        >
            {renderContent()}
        </PageBody>
    )
}
